{"entries":[{"timestamp":1764298883722,"editorVersion":"2.0.62","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":13785,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":189,"length1":41,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":218,"length1":75,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.py","value":"@namespace\nclass SpriteKind:\n    Wall = SpriteKind.create()\n\"\"\"\n\n---------- prevent walking through walls ----------\n\n\"\"\"\n\"\"\"\n\n---------- end of file ----------\n\n\"\"\"\n# ---------- INPUT: menu navigation + unified A handler ----------\n\ndef on_up_pressed():\n    global selected\n    if currentApp != App.Menu:\n        return\n    selected = (selected - 1 + len(menuItems)) % len(menuItems)\n    drawMenu()\ncontroller.up.on_event(ControllerButtonEvent.PRESSED, on_up_pressed)\n\n# convert grid (r,c) to pixel center\ndef gridToPixel(c: number, r: number):\n    global totalW, totalH, offsetX, offsetY, px, py\n    totalW = gridCols * CELL\n    totalH = gridRows * CELL\n    offsetX = Math.floor((160 - totalW) / 2)\n    offsetY = Math.floor((120 - totalH) / 2)\n    px = offsetX + c * CELL + Math.floor(CELL / 2)\n    py = offsetY + r * CELL + Math.floor(CELL / 2)\n    return [px, py]\n\ndef on_b_pressed():\n    global currentApp\n    # back to menu from any game\n    if currentApp != App.Menu:\n        destroyAllKinds()\n        currentApp = App.Menu\n        drawMenu()\ncontroller.B.on_event(ControllerButtonEvent.PRESSED, on_b_pressed)\n\n# ---------- MAZE: generation (recursive backtracker) ----------\ndef initMazeGrid():\n    global mazeGrid\n    mazeGrid = []\n    s = 0\n    while s <= gridRows - 1:\n        mazeGrid[s] = []\n        d = 0\n        while d <= gridCols - 1:\n            # wall\n            # wall\n            mazeGrid[s][d] = 0\n            d += 1\n        s += 1\n# ---------- SHOOTER: start ----------\ndef startShooter():\n    global currentApp, shooterEnemyHP, shooterPlayer, shooterEnemy\n    destroyAllKinds()\n    currentApp = App.Shooter\n    scene.set_background_color(7)\n    info.set_score(0)\n    info.set_life(3)\n    shooterEnemyHP = 3\n    shooterPlayer = sprites.create(img(\"\"\"\n            . 4 4 .\n            4 4 4 4\n            4 4 4 4\n            . 4 4 .\n            \"\"\"),\n        SpriteKind.player)\n    shooterPlayer.set_position(20, 60)\n    shooterPlayer.set_stay_in_screen(True)\n    controller.move_sprite(shooterPlayer, 100, 100)\n    shooterEnemy = sprites.create(img(\"\"\"\n            . 2 2 .\n            2 2 2 2\n            2 2 2 2\n            . 2 2 .\n            \"\"\"),\n        SpriteKind.enemy)\n    shooterEnemy.set_position(140, 60)\n\ndef on_on_overlap(pl, en):\n    if currentApp != App.Shooter:\n        return\n    info.change_life_by(-1)\n    scene.camera_shake(4, 200)\n    pause(300)\n    if info.life() <= 0:\n        game.over(False)\nsprites.on_overlap(SpriteKind.player, SpriteKind.enemy, on_on_overlap)\n\n# SINGLE A handler (menu select, shooter shoot, maze no-op)\n# MAZE: A does nothing (could be used for auto-solve later)\n\ndef on_a_pressed():\n    global currentApp\n    # MENU select\n    if currentApp == App.Menu:\n        if selected == 0:\n            startShooter()\n            return\n        elif selected == 1:\n            startMaze()\n            return\n        else:\n            currentApp = App.ComingSoon\n            return\n    # SHOOTER shooting\n    if currentApp == App.Shooter:\n        # cost\n        info.change_score_by(-1)\n        sprites.create_projectile_from_sprite(img(\"\"\"\n                . 1 .\n                1 1 1\n                . 1 .\n                \"\"\"),\n            shooterPlayer,\n            160,\n            0)\n        return\ncontroller.A.on_event(ControllerButtonEvent.PRESSED, on_a_pressed)\n\ndef spawnMazeSprites():\n    global mazeWalls, pos, wall\n    # destroy old walls\n    for w in mazeWalls:\n        w.destroy()\n    mazeWalls = []\n    t = 0\n    while t <= gridRows - 1:\n        e = 0\n        while e <= gridCols - 1:\n            if mazeGrid[t][e] == 0:\n                pos = gridToPixel(e, t)\n                wall = sprites.create(image.create(CELL, CELL), SpriteKind.Wall)\n                # fill wall image\n                yy = 0\n                while yy <= CELL - 1:\n                    xx = 0\n                    while xx <= CELL - 1:\n                        wall.image.set_pixel(xx, yy, 8)\n                        xx += 1\n                    yy += 1\n                wall.set_position(pos[0], pos[1])\n                wall.set_flag(SpriteFlag.GHOST, False)\n                mazeWalls.append(wall)\n            e += 1\n        t += 1\n\ndef on_down_pressed():\n    global selected\n    if currentApp != App.Menu:\n        return\n    selected = (selected + 1) % len(menuItems)\n    drawMenu()\ncontroller.down.on_event(ControllerButtonEvent.PRESSED, on_down_pressed)\n\ndef on_on_overlap2(proj, pl2):\n    if currentApp != App.Shooter:\n        return\n    proj.destroy()\n    info.change_life_by(-1)\n    if info.life() <= 0:\n        game.over(False)\nsprites.on_overlap(SpriteKind.projectile, SpriteKind.player, on_on_overlap2)\n\n# ---------- CLEANUP helpers ----------\ndef destroyAllKinds():\n    sprites.destroy_all_sprites_of_kind(SpriteKind.player)\n    sprites.destroy_all_sprites_of_kind(SpriteKind.enemy)\n    sprites.destroy_all_sprites_of_kind(SpriteKind.projectile)\n    sprites.destroy_all_sprites_of_kind(SpriteKind.food)\n    sprites.destroy_all_sprites_of_kind(SpriteKind.Wall)\n# start at (1,1)\ndef carveMaze():\n    global sr, sc, top, u, f, n, nr, nc\n    stack: List[List[number]] = []\n    initMazeGrid()\n    sr = 1\n    sc = 1\n    mazeGrid[sr][sc] = 1\n    stack.append([sr, sc])\n    while len(stack) > 0:\n        neighbors: List[List[number]] = []\n        top = stack[len(stack) - 1]\n        u = top[0]\n        f = top[1]\n        # Up\n        if u - 2 > 0 and mazeGrid[u - 2][f] == 0:\n            neighbors.append([u - 2, f])\n        # Down\n        if u + 2 < gridRows and mazeGrid[u + 2][f] == 0:\n            neighbors.append([u + 2, f])\n        # Left\n        if f - 2 > 0 and mazeGrid[u][f - 2] == 0:\n            neighbors.append([u, f - 2])\n        # Right\n        if f + 2 < gridCols and mazeGrid[u][f + 2] == 0:\n            neighbors.append([u, f + 2])\n        if len(neighbors) > 0:\n            n = neighbors[randint(0, len(neighbors) - 1)]\n            nr = n[0]\n            nc = n[1]\n            midR = (u + nr) >> 1\n            midC = (f + nc) >> 1\n            mazeGrid[midR][midC] = 1\n            mazeGrid[nr][nc] = 1\n            stack.append([nr, nc])\n        else:\n            stack.pop()\n# ---------- collision: player reaches goal ----------\n\ndef on_on_overlap3(sprite, otherSprite):\n    global mazeBest, currentApp\n    if currentApp != App.Maze:\n        return\n    game.splash(\"TIME: \" + str(mazeTimer) + \"s\")\n    if mazeTimer < mazeBest:\n        mazeBest = mazeTimer\n        settings.write_number(\"mazeBest\", mazeBest)\n        game.splash(\"NEW RECORD!\")\n    destroyAllKinds()\n    currentApp = App.Menu\n    drawMenu()\nsprites.on_overlap(SpriteKind.player, SpriteKind.food, on_on_overlap3)\n\n# shooter collisions\n\ndef on_on_overlap4(proj2, en2):\n    global shooterEnemyHP, shooterEnemy\n    if currentApp != App.Shooter:\n        return\n    proj2.destroy()\n    shooterEnemyHP += -1\n    music.pew_pew.play()\n    # refund\n    info.change_score_by(1)\n    if shooterEnemyHP <= 0:\n        en2.destroy(effects.disintegrate, 300)\n        info.change_score_by(10)\n        pause(200)\n        # respawn enemy\n        shooterEnemy = sprites.create(img(\"\"\"\n                . 2 2 .\n                2 2 2 2\n                2 2 2 2\n                . 2 2 .\n                \"\"\"),\n            SpriteKind.enemy)\n        shooterEnemy.set_position(140, randint(20, 100))\n        shooterEnemyHP = 3\nsprites.on_overlap(SpriteKind.projectile, SpriteKind.enemy, on_on_overlap4)\n\n# ---------- START MAZE ----------\ndef startMaze():\n    global currentApp, mazeTimer, startPos, mazePlayer, exitR, exitC, exitPos, mazeGoal, prevX, prevY\n    destroyAllKinds()\n    currentApp = App.Maze\n    scene.set_background_color(6)\n    mazeTimer = 0\n    carveMaze()\n    spawnMazeSprites()\n    # place player at start (1,1)\n    startPos = gridToPixel(1, 1)\n    mazePlayer = sprites.create(img(\"\"\"\n            . 7 7 .\n            7 7 7 7\n            7 7 7 7\n            . 7 7 .\n            \"\"\"),\n        SpriteKind.player)\n    mazePlayer.set_position(startPos[0], startPos[1])\n    controller.move_sprite(mazePlayer, 80, 80)\n    mazePlayer.set_stay_in_screen(True)\n    # place goal at opposite corner (gridRows-2, gridCols-2)\n    exitR = gridRows - 2\n    exitC = gridCols - 2\n    # make sure it's open\n    # make sure it's open\n    mazeGrid[exitR][exitC] = 1\n    exitPos = gridToPixel(exitC, exitR)\n    mazeGoal = sprites.create(img(\"\"\"\n            . 2 2 .\n            2 2 2 2\n            2 2 2 2\n            . 2 2 .\n            \"\"\"),\n        SpriteKind.food)\n    mazeGoal.set_position(exitPos[0], exitPos[1])\n    # record previous player pos for wall collision revert\n    prevX = mazePlayer.x\n    prevY = mazePlayer.y\n# ---------- MENU ----------\ndef drawMenu():\n    global y\n    scene.set_background_color(9)\n    screen.fill(9)\n    screen.print_center(\"MEWY OS\", 10, 1)\n    i = 0\n    while i <= len(menuItems) - 1:\n        y = 40 + i * 18\n        if i == selected:\n            # red selection rectangle (stroke)\n            screen.draw_rect(18, y - 4, 124, 16, 2)\n        screen.print(menuItems[i], 30, y, 1)\n        i += 1\n    screen.print_center(\"A = Select   B = Back\", 110, 1)\n    screen.print_center(\"BEST MAZE: \" + str(mazeBest) + \"s\", 100, 1)\ny = 0\nprevY = 0\nprevX = 0\nexitPos: List[number] = []\nexitC = 0\nexitR = 0\nstartPos: List[number] = []\nnc = 0\nnr = 0\nn: List[number] = []\nf = 0\nu = 0\ntop: List[number] = []\nsc = 0\nsr = 0\nwall: Sprite = None\npos: List[number] = []\nmazeWalls: List[Sprite] = []\nmazeGrid: List[List[number]] = []\npy = 0\npx = 0\noffsetY = 0\noffsetX = 0\ntotalH = 0\ntotalW = 0\nselected = 0\ngridRows = 0\ngridCols = 0\nCELL = 0\nshooterEnemyHP = 0\nmenuItems: List[str] = []\nmazeTimer = 0\nmazeGoal: Sprite = None\n# --- global vars for maze ---\nmazePlayer: Sprite = None\nshooterEnemy: Sprite = None\n# --- global vars for shooter ---\nshooterPlayer: Sprite = None\nclass App(Enum):\n    Boot = 0\n    Menu = 1\n    Shooter = 2\n    Maze = 3\n    ComingSoon = 4\ncurrentApp = App.Boot\nmenuItems = [\"Shooter\", \"Maze\", \"Coming Soon\"]\nshooterEnemyHP = 3\nmazeBest = settings.read_number(\"mazeBest\")\nif mazeBest == 0:\n    mazeBest = 9999\n# Maze grid parameters (odd-grid carving)\n# number of cell columns (odd carving grid will be 2*MAZE_CELLS_X+1)\nMAZE_CELLS_X = 11\nMAZE_CELLS_Y = 7\n# pixel size per grid cell (small so fits 160x120)\nCELL = 6\ngridCols = MAZE_CELLS_X * 2 + 1\ngridRows = MAZE_CELLS_Y * 2 + 1\n# 0 = wall, 1 = path\n# ---------- BOOT ----------\nscene.set_background_color(1)\nlogo = sprites.create(img(\"\"\"\n        . . f f . . . . . . . . . f f . .\n        . . f 1 f . . . . . . . f 1 f . .\n        . . f 1 1 f . . . . . f 1 1 f . .\n        . . f 1 1 1 f f f f f 1 1 1 f . .\n        . . f 1 1 1 1 1 1 1 1 1 1 1 f . .\n        . f 1 1 1 1 1 1 1 1 1 1 1 1 1 f .\n        . f 1 1 f 9 1 1 1 1 1 f 9 1 1 f .\n        . f 1 1 f 9 1 1 1 1 1 f 9 1 1 f .\n        . f 1 1 1 1 1 1 1 1 1 1 1 1 1 f .\n        . f 1 1 1 1 1 1 3 1 1 1 1 1 1 f .\n        . . f 1 1 1 1 1 1 1 1 1 1 1 f . .\n        . . . f 1 1 1 1 1 1 1 1 1 f . . .\n        . . . . f f f f f f f f f . . . .\n        \"\"\"),\n    SpriteKind.player)\nlogo.set_position(80, 50)\nlogo.say(\"Mewy OS\", 1200)\nmySprite = sprites.create(img(\"\"\"\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        \"\"\"),\n    SpriteKind.player)\nmySprite.set_position(80, 100)\nmySprite.say_text(\"Powerd By: CocoKitten2016\", 1200, False)\nmusic.power_up.play()\npause(1300)\nsprites.destroy(mySprite)\nlogo.destroy()\ncurrentApp = App.Menu\ndrawMenu()\n\ndef on_on_paint():\n    if currentApp == App.Menu:\n        drawMenu()\n    elif currentApp == App.Shooter:\n        screen.print_center(\"SHOOTER\", 8, 1)\n        screen.print(\"Enemy HP: \" + str(shooterEnemyHP), 2, 2, 1)\n        screen.print(\"Score:\" + str(info.score()), 2, 12, 1)\n    elif currentApp == App.Maze:\n        # HUD\n        screen.print(\"TIME: \" + str(mazeTimer) + \"s\", 2, 2, 1)\n        screen.print(\"BEST: \" + str(mazeBest) + \"s\", 2, 12, 1)\n        # minimap box top-right\n        mapX = 110\n        mapY = 2\n        mapW = 46\n        mapH = 30\n        screen.draw_rect(mapX, mapY, mapW, mapH, 1)\n        # draw player dot and goal dot scaled to map (scale positions)\n        if mazePlayer:\n            px2 = mapX + Math.floor((mazePlayer.x / 160) * (mapW - 4)) + 1\n            py2 = mapY + Math.floor((mazePlayer.y / 120) * (mapH - 4)) + 1\n            screen.fill_rect(px2, py2, 2, 2, 7)\n        if mazeGoal:\n            gx = mapX + Math.floor((mazeGoal.x / 160) * (mapW - 4)) + 1\n            gy = mapY + Math.floor((mazeGoal.y / 120) * (mapH - 4)) + 1\n            screen.fill_rect(gx, gy, 2, 2, 2)\n    elif currentApp == App.ComingSoon:\n        screen.fill(9)\n        screen.print_center(\"COMING SOON\", 60, 2)\n        screen.print_center(\"Press B\", 90, 1)\ngame.on_paint(on_on_paint)\n\ndef on_on_update():\n    global prevX, prevY\n    # move is applied by engine on every frame; after a short delay we'll check collisions in next onUpdate\n    if currentApp == App.Maze and mazePlayer:\n        # store previous\n        prevX = mazePlayer.x\n        prevY = mazePlayer.y\ngame.on_update(on_on_update)\n\n# ---------- Maze timer ----------\n\ndef on_update_interval():\n    global mazeTimer\n    if currentApp == App.Maze:\n        mazeTimer += 1\ngame.on_update_interval(1000, on_update_interval)\n\ndef on_update_interval2():\n    if currentApp != App.Maze or not (mazePlayer):\n        return\n    # after movement, check overlap with any wall; if overlapping, revert to previous pos\n    for a in mazeWalls:\n        if mazePlayer.overlaps_with(a):\n            mazePlayer.set_position(prevX, prevY)\n            return\ngame.on_update_interval(20, on_update_interval2)\n\n# enemy AI: chase\n\ndef on_update_interval3():\n    if currentApp != App.Shooter:\n        return\n    if not (shooterEnemy) or not (shooterPlayer):\n        return\n    shooterEnemy.vx = -40 if shooterPlayer.x < shooterEnemy.x else 40\n    shooterEnemy.vy = -40 if shooterPlayer.y < shooterEnemy.y else 40\ngame.on_update_interval(200, on_update_interval3)\n"}]}],"snapshots":[{"timestamp":1764298883721,"editorVersion":"2.0.62","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Mewy OS 1-0 release\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1764299168557}